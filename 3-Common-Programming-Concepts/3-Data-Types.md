# 数据类型

Rust 中所有值都属于某一确定的数据类型，数据类型确定了数据所属的类别，Rust 会因此以不同方式处理数据。本章节我们会学到数据类型的两个子集：标量（scalar）和复合（compound）。

时刻牢记，Rust 是静态类型语言，即编译时 Rust 必须能获取到所有变量的类型。通常情况下，编译器能够基于变量值和使用方法，推断出我们想要使用得是什么类型。而在某些情况下，推断结果包括多种可能，例如第二章的“对比猜测值与秘密数字”章节中，我们使用 `parse` 将 `String` 类型转化为数字类型，此时就必须加上类型注解，如下所示：

```rs
#![allow(unused_variables)]
fn main() {
    let guess: u32 = "42".parse().expect("Not a number!");
}
```

而如果我们没有添加类型注解，Rust 就会报错，这意味着编译器需要开发者提供更多关于所用变量类型的信息。Rust 报错信息如下：

```sh
error[E0282]: type annotations needed
 --> src/main.rs:2:9
  |
2 |     let guess = "42".parse().expect("Not a number!");
  |         ^^^^^
  |         |
  |         cannot infer type for `_`
  |         consider giving `guess` a type
```

下面我们将会看到各种不同数据类型的类型注解。

## 标量类型

标量类型代表了一个独立的值。Rust 有四种主要的标量类型：整数类型、浮点数、布尔值和字符类型。也许你在其他编程语言中也曾见到过它们。现在我们将深入探讨它们在 Rust 中是如何运作的。

### 整数类型

整数即没有小数部分的数字。在第二章中我们曾经使用过整数类型 `u32`。这种整数类型的值是无符号整数（有符号整数类型以 `i` 开头，而无符号的则以 `u` 开头），它占用 32 比特空间。如下表格 3-1 展示了 Rust 所有内建整数类型。有符号和无符号这两列下的每个变体（例如 `i16`）都可以用来声明整数值的类型。

表格 3-1：Rust 中的整数类型

| 占用空间长度 | 有符号	| 无符号 |
| :----: | :----: | :----: |
| 8-bit	| `i8` | `u8` | 
| 16-bit | `i16` | `u16` | 
| 32-bit | `i32` | `u32` | 
| 64-bit | `i64` | `u64` | 
| 128-bit | `i128` | `u128` | 
| arch | `isize` | `usize` | 

每种变体都可能是有符号或无符号的，并且也指明了大小。有符号和无符号表示数字是否可能为负数 —— 换句话说，有符号数需要一个符号来指定正负，而无符号数一定是正数，因此就不需要符号表示。这和我们书写数字很类似：当符号有意义时，数字前面就需要写一个加号或者减号；而当数字一定是正数时，就不需要写符号了。有符号数使用[补码形式](https://en.wikipedia.org/wiki/Two%27s_complement)存储。

有符号类型的变体可以存储 <img src="https://latex.codecogs.com/gif.latex?-2^{n-1}" title="-2^{n-1}" /> 到 <img src="https://latex.codecogs.com/gif.latex?2^{n-1}-1" title="2^{n-1}-1"/> 之内的数字（包括 <img src="https://latex.codecogs.com/gif.latex?-2^{n-1}" title="-2^{n-1}" /> 和 <img src="https://latex.codecogs.com/gif.latex?2^{n-1}-1" title="2^{n-1}-1" />），其中 n 表示该变体使用的比特数。因此 `i8` 可以存储 <img src="https://latex.codecogs.com/gif.latex?-2^{7}" title="-2^{7}" /> 到 <img src="https://latex.codecogs.com/gif.latex?2^{7}-1" title="2^{7}-1" /> 的数字，也就是 -128 到 127。而无符号类型的变体存储从 0 到 <img src="https://latex.codecogs.com/gif.latex?2^{n}-1" title="2^{n}-1" /> 的数字，因此 `u8` 可以存储从 0 到 <img src="https://latex.codecogs.com/gif.latex?2^{8}-1" title="2^{8}-1"/> 即 0 到 255 的数字。

（译者注：如果图片无法正常显示，可将鼠标悬浮于图片上查看图片 title 信息）

另外，`isize` 和 `usize` 两类则需要依赖于程序运行的设备：如果您的设备是 64 比特的，那么该值占用空间长度也为 64 比特；32 比特设备同理。

我们可以使用表 3-2 中的任何格式编写数字。注意，除了 Byte 之外的所有格式都可以添加类型后缀，例如 `57u8`，同时 `_` 符号可用作分隔线以方便读数，例如 `1_000`。

表 3-2：Rust 中的整数编写格式

| 数字编写格式 | 示例
| :----: | :----: |
| Decimal |	`98_222` |
| Hex |	`0xff` |
| Octal |	`0o77` |
| Binary |	`0b1111_0000` |
| Byte (仅限 `u8` 类型) |	`b'A'` |

那么我们如何选择使用何种整数类型呢？如果编程时我们并不能确定，使用 Rust 的默认类型通常是不错的选择，整数的默认类型是 `i32`：这个类型（的操作）通常是最快的，即使是在 64 比特系统也是如此。而当为某种集合建立索引时，最好的选择是使用 `isize` 或 `usize`。

> 整型溢出 <br/>
> 一个 `u8` 类型的变量能保存的数值为 0 到 255。而如果试图将变量值修改为一个此范围外的数字，例如 256，就会发生整型溢出。Rust 有一些很有意思的规则会涉及这种行为。当我们在调试模式编译时，Rust 会检查整型溢出，并在发生溢出时使程序 panic。每当程序由于错误而退出时，Rust 都会使用这种形式；我们将会在第九章的“不可恢复的错误与 panic”章节中详细讨论 panic。
> 而当我们使用标识 `--release` 在发版（release）模式下编译时，Rust 则不会检查整型溢出，也不会使程序 panic。而如果此时还是发生了整型溢出，Rust 会使用补码包装。简单来说，大于类型最大值的数值将会被“环绕”回该类型最小值处。例如如果是数值为 256 的 `u8` 类型，那么它就会变为 0，257 就会变为 1，以此类推。程序不会进入 panic，但是变量也不是你想要的那个值了。依赖整型溢出的环绕行为来完成功能其实是一种错误。而如果您想要明确指定让数值进行“环绕”，可以使用标准库类型 [`Wrapping`](https://doc.rust-lang.org/std/num/struct.Wrapping.html)。

### 浮点类型

Rust 有两种原生浮点数类型，它们是带小数点的数字。Rust 中的浮点类型是 `f32` 和 `f64`，分别为 32 比特和 64 比特大小。Rust 默认的浮点类型是 `f64`，因为这两种类型在现代 CPU 中运算速度相同，而 `f64` 能够存储精度更高的数字。

下面这个例子向我们展示了如何在代码中操作浮点数：

文件名：src/main.rs

```rs
fn main() {
    let x = 2.0; // f64

    let y: f32 = 3.0; // f32
}
```

浮点数的表示遵守 IEEE-754 标准。`f32` 类型是单精度浮点，而 `f64` 是双精度浮点。

### 数值运算

Rust 支持所有数字类型的基本数学运算，例如加法、减法、乘法、除法和取余。如下代码展示了如何在 `let` 语句中使用这些运算：

文件名：src/main.rs

```rs
fn main() {
    // 加法
    let sum = 5 + 10;

    // 减法
    let difference = 95.5 - 4.3;

    // 乘法
    let product = 4 * 30;

    // 除法
    let quotient = 56.7 / 32.2;

    // 取余
    let remainder = 43 % 5;
}
```

上述每个语句中的表达式都使用了一种数学运算，并都会得出一个将会和变量绑定的数值。如果您想知道 Rust 所支持的所有运算符，请参考附录 B 中的列表。

### 布尔类型

和其他大部分编程语言类似，Rust 布尔类型只有两种可能的值：`true` 和 `false`。布尔值占用一个字节空间。Rust 中的布尔类型使用 `bool` 声明。例如：

文件名：src/main.rs

```rs
fn main() {
    let t = true;

    let f: bool = false; // 使用显式类型注解
}
```

使用布尔值最主要的场景是在条件表达式中，例如 `if` 表达式。我们将会在“控制流”章节中详细介绍 Rust 中 `if` 表达式的原理。

（译者注：感觉这里应该是 `if` 语句而非表达式）

### 字符类型

到目前为止，我们只接触到了数字类型，而其实 Rust 也支持字母。`char` 类型是 Rust 语言中最基础的字母类型，如下代码向我们展示了使用 `char` 的一种方式。（注意，`char` 类型文字使用单引号包裹，而字符串文字则使用双引号。）

文件名：src/main.rs

```rs
fn main() {
    let c = 'z';
    let z = 'ℤ';
    let heart_eyed_cat = '😻';
}
```

Rust 的 `char` 类型占用 4 字节空间，它代表了一个 Unicode 编码的标量值，这就意味着它可以表示的字符范围将远多于 ASCII。拼音、中文、日文和韩文字符，emoji 表情符号，以及零长度空格字符都可以是 Rust `char` 类型的有效值。Unicode 标量值包含从 `U+0000` 到 `U+D7FF`，以及从 `U+E000` 到 `U+10FFFF` 的闭区间内的所有值。但是“字符”并不是 Unicode 中的概念，所以我们直觉中的“字符”也许和 Rust 中的 `char` 是不同的。我们将会在第八章的“使用字符串存储 UTF-8 编码的文本”章节中详细讨论这个问题。

## 复合类型

复合类型可以将多个值组合在一起。Rust 有两种原生复合类型：元组和数组。

### 元组类型（Tuple Type）

元组常用来组合多个不同类型的值。元组长度固定：即一旦元组完成声明，就不可增长或缩短了。

多个值组成列表并使用逗号分隔，将其包裹于括号内即可创建一个元组。元组中每个值都有自己的类型，不同值的类型也不必相同。下面这个例子中添加了类型注解（类型注解可省略）：

文件名：src/main.rs

```rs
fn main() {
    let tup: (i32, f64, u8) = (500, 6.4, 1);
}
```

由于元组是一个单独的复合类型元素，所以变量 `tup` 将会和整个元组绑定。如果想要获取元组中的某一个值，可以像下面这样使用模式匹配来解构元组值：

文件名：src/main.rs

```rs
fn main() {
    let tup = (500, 6.4, 1);

    let (x, y, z) = tup;

    println!("The value of y is: {}", y);
}
```

这段程序首先创建了一个元组并将其绑定到变量 `tup`。接下来使用 `let` 加一个模式将元组拆分为三个变量：`x`、`y` 和 `z`。这就称为解构，解构可以将单一元组拆分为多个部分。最后，程序打印出了 `y` 的值，即 `6.4`。

除了使用模式匹配来解构元组，我们还可以使用点号 `.` 加索引序号来直接访问元组元素。例如：

文件名：src/main.rs

```rs
fn main() {
    let x: (i32, f64, u8) = (500, 6.4, 1);

    let five_hundred = x.0;

    let six_point_four = x.1;

    let one = x.2;
}
```

这段程序首先创建了元组和变量 `x`，然后使用元素各自的索引为其创建了新的变量。和大多数的编程语言一样，元组首个索引值为 0。

### 数组类型

另一种集合多个值的方式就是使用数组。和元组不同，数组中所有元素必须属于同一种类型。Rust 数组和其他语言中的数组不同，它的长度必须固定，这点和元组一样。

Rust 数组中的值使用逗号分隔，并使用方括号包裹：

文件名：src/main.rs

```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
}
```

当我们希望数据以栈而不是堆的形式（我们在第四章会深入讨论栈和堆）操控，或者希望能确保元素数量固定的时候，数组就很实用了。但是数组确实不如向量（vector）类型那样灵活。向量类型是标准库提供的一种和数组很类似的集合类型，但是它的长度可以改变。如果您无法确定是使用数组还是向量，那么建议使用向量。我们将会在第八章详细讨论向量类型

例如程序需要一年中所有月份的名字，那么我们就应该使用数组而不是向量。因为我们几乎不可能会需要程序增加或减少月份，我们此时就应该使用数组，它一定包含 12 个元素：

```sh
let months = ["January", "February", "March", "April", "May", "June", "July",
              "August", "September", "October", "November", "December"];
```

在方括号中写入数组元素的类型，紧跟着写一个分号，然后是数组元素的个数，这样就组成了数组的类型，如下：

```rs
#![allow(unused_variables)]
fn main() {
    let a: [i32; 5] = [1, 2, 3, 4, 5];
}
```

`i32` 表示数组中元素的类型。分号后的数字 `5` 表示数组中包含了五个元素。

这样的数组类型格式和初始化数组另一种方式很像：如果想要创建一个包含数个相同值的元素的数组，我们可以指明元素的值，紧跟着一个分号，然后给出数组的长度，并用方括号包裹，如下所示：

```rs
#![allow(unused_variables)]
fn main() {
    let a = [3; 5];
}
```

数组 `a` 将会包含 `5` 个元素，它们的值都会被初始化为 `3`。这种方式和 `let a = [3, 3, 3, 3, 3];` 的结果是一样的，但是更加精简。

#### 访问数组元素

数组是栈中分配的一整块内存。我们可以使用索引访问数组元素，像这样：

文件名：src/main.rs
```rs
fn main() {
    let a = [1, 2, 3, 4, 5];

    let first = a[0];
    let second = a[1];
}
```

这段代码中，变量 `first` 的值是 `1`，即数组中索引为 `[0]` 的值。变量 `second` 的值是 `2`，即数组中索引为 `[1]` 的值。

#### 访问无效的数组元素

如果我们尝试使用数组最大长度之外的索引获取数组元素会怎样呢？假如我们将代码修改为如下所示，那么这段代码将可以完成编译，但是会在运行时报错：

文件名：src/main.rs

代码将会 panic！
```rs
fn main() {
    let a = [1, 2, 3, 4, 5];
    let index = 10;

    let element = a[index];

    println!("The value of element is: {}", element);
}
```

使用 `cargo run` 运行代码，我们将会看到如下输出结果：

```sh
$ cargo run
   Compiling arrays v0.1.0 (file:///projects/arrays)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/arrays`
thread 'main' panicked at 'index out of bounds: the len is 5 but the index is
 10', src/main.rs:5:19
note: Run with `RUST_BACKTRACE=1` for a backtrace.
```

编译过程没有报错，但最终程序还是会在运行时报错，并且没有成功退出。当我们尝试使用索引访问数组元素时，Rust 将会检查该索引是否小于数组长度。如果索引大于等于数组长度，Rust 将会 panic。

这是我们实践 Rust 代码安全准则的第一个例子。在很多底层语言中并没有这种检查，而当开发者使用了错误的索引时，就会访问到无效内存。但 Rust 则会马上退出，而不是允许开发者访问无效内存并继续执行程序，如此可以让开发者尽可能避免此类错误。在第九章中我们将详细谈论 Rust 的错误处理。
