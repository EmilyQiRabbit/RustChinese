# 变量与可变性

我们在第二章提到过，变量都是默认不可修改的。这是 Rust 为开发者编程提供的的众多便捷之一，如此可以充分发挥出 Rust 的安全性和轻松并发的优势。但无论如何，我们还是有办法可以修改变量。下面就让我们一起探索为何 Rust 要支持开发者使用不可变量，以及什么时候我们需要修改变量。

如果变量不可修改，那么一旦将某个值赋值给变量名，这个值就不能被修改了。下面我们通过实践来更好的说明这一点，首先通过命令 `cargo new variables` 在 projects 目录下新建一个名为 variables 的项目。

然后，在 variables 目录下，打开 src/main.rs 文件，使用如下还无法编译的代码替换掉原来的内容：

文件名：src/main.rs

（注：这些代码无法编译）
```rs
fn main() {
    let x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

保存代码然后使用 `cargo run` 运行程序。我们将会看到类似如下的报错信息：

```sh
error[E0384]: cannot assign twice to immutable variable `x`
 --> src/main.rs:4:5
  |
2 |     let x = 5;
  |         - first assignment to `x`
3 |     println!("The value of x is: {}", x);
4 |     x = 6;
  |     ^^^^^ cannot assign twice to immutable variable
```

本示例说明了编译器是如何帮助我们在程序中发现错误的。尽管如此，编译错误还是挺让人感到泄气的，记住，错误仅仅意味着您的程序还没能安全的完成预期的功能；但并不能说明您的编程能力不够好！非常有经验的 Rust 开发者也一样会遇到编译错误。

错误信息说明了错误的原因是 `cannot assign twice to immutable variable x`，即不能为不可变量赋值两次；而在示例代码中，我们尝试为不可变量 `x` 做了第二次赋值。

当我们试图修改一个被指定为不可变的变量值的时候，我们会获取到编译错误，这是非常重要的，因为这种情况下很可能出现问题。如果我们在一段代码中假定变量值绝不会改变，而在另一段代码中却修改了变量值，那么很可能第一段代码就无法按照预期工作。这种错误的原因可能很难追踪，尤其是当第二段代码仅在某些情况下会修改变量值，而某些情况不会的时候。

Rust 编译器能保证您声明的变量值不会被修改。这意味着当您在读写代码时，不需要追踪变量值在何时何处可能被修改。因此代码将更易于解读。

但同时，可变性也很实用。变量仅在默认情况下是不可修改的；但是正如我们第二章中的做法，在变量名前添加 `mut` 即可让变量可修改。除了让变量值变得可以修改，`mut` 还能够向后来的代码阅读者传达这样的信息，即其他代码此后可以修改该变量的值。

例如，我们将 src/main.rs 修改为：

文件名：src/main.rs

```rs
fn main() {
    let mut x = 5;
    println!("The value of x is: {}", x);
    x = 6;
    println!("The value of x is: {}", x);
}
```

然后运行项目，我们将在终端看到：

```sh
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.30 secs
     Running `target/debug/variables`
The value of x is: 5
The value of x is: 6
```

使用 `mut` 之后，我们可以将 `x` 的值从 `5` 修改为 `6` 了。某些场景下，我们希望让变量可修改，相比于代码只能定义不可改变量，这样能更加简便。

除了要防止错误，开发者还需要多方权衡考虑。例如我们想要使用一个很大的数据结构，那么直接修改该实例就要比拷贝然后返回新创建的实例要快得多。而对于相对小的数据结构，创建新的实例，并使用更函数化的编程方式可能会更直观，这时候牺牲一些性能来换取清晰的逻辑，可能就是值得的了。

## 变量和常量的区别

无法修改的变量值，这可能会让你想起另一个大多数编程语言都有的概念：常量。和不可修改变量类似，常量也同样是一旦赋值就不可修改，但是常量和不可修改的变量之间还是稍有区别的。

首先，不允许使用 `mut` 修饰常量。常量不是默认配置了不可修改（意味着还可以配置为可修改） —— 它们就是永远不可修改。

使用关键字 `const` 而不是 `let` 来声明常量，同时必须注明值的类型。我们将会在下一章“数据类型”中为您讲解类型和类型注解，这里我们先略过细节，只需要知道此时必须注明类型即可。

常量可在任何作用域内声明，当然也包括全局作用域，此时任何代码都可以使用这些常量。

最后一点区别是，常量必须使用常量表达式赋值，而不可使用函数的结果或者其他任何只能在运行时才能被计算出的值。

下面是一个常量声明的示例，常量名为 `MAX_POINTS`，值为 100,000。（Rust 常量命名的惯例是使用下划线链接大写字母组成的单词，同时，在数字中插入下划线可以增加可读性）：

```rs
#![allow(unused_variables)]
fn main() {
const MAX_POINTS: u32 = 100_000;
}
```

程序运行时，作用域内的常量始终保持不变；所以当应用中程序的多个部分都需要某一值的时候，常量就有了用武之地，例如游戏玩家可以获得的最高分或者，emmmmmm，光速！

在程序中将硬编码值声明为常量，能向代码将来的维护者传递出有效的信息。同时如果后续硬编码值需要更新，开发者只需要修改常量声明处的代码即可。

## 遮盖

正如在第二章游戏教程的“对比猜谜结果”章节中讨论的那样，我们可以声明已有变量的同名的变量，此时新的变量将会把前面已有变量遮盖掉。Rust 开发者将其称为，第一个变量被第二个变量遮盖了，意味着第二个变量的值最终会被使用。我们可以通过使用同名变量并重复使用 `let` 关键字来遮盖变量，如下所示：

文件名：src/main.rs

```rs
fn main() {
    let x = 5;

    let x = x + 1;

    let x = x * 2;

    println!("The value of x is: {}", x);
}
```

该程序首先将 `x` 赋值为 `5`。然后重复使用 `let x =` 遮盖了前面的 `x`，表达式使用了初始值并加 `1`，那么当前 `x` 值就是 `6`。第三个 `let` 语句再次遮盖了 `x`，表达式将 `x` 乘以 `2`，它最终的值变成了 `12`。当我们运行程序时，终端将会输出：

```sh
$ cargo run
   Compiling variables v0.1.0 (file:///projects/variables)
    Finished dev [unoptimized + debuginfo] target(s) in 0.31 secs
     Running `target/debug/variables`
The value of x is: 12
```

遮盖和使用 `mut` 变量是不同的，当我们不小心忘记使用 `let` 关键字而试图重新为变量赋值时，编译器会报编译时错误。而如果使用 `let`，就可以在修改变量值的同时，保留修改完成后变量的不可改性。

另一个区别是，当再次使用 `let` 关键字时，我们其实是高效创建了一个新的变量，即可以修改变量的类型和值，但是重复使用变量名。例如，假如程序希望用户通过输入空格，给出他们希望的字符间距，而是我们希望保存的数据的是空格的个数：

```rs
let spaces = "   ";
let spaces = spaces.len();
```

这样构建代码是合法的，因为第一个 `spaces` 变量是字符串类型，而第二个新建的同名 `spaces` 变量是数字类型。遮盖特性让我们可以不必非要使用不同的变量名，例如 `spaces_str` 和 `spaces_num`，而是可以重复使用更简单的 `spaces`。但是，如果我们此时尝试使用 `mut`，编译器也会报编译时错误：

```rs
let mut spaces = "   ";
spaces = spaces.len();
```

错误表明，我们不可以修改变量类型：

```sh
error[E0308]: mismatched types
 --> src/main.rs:3:14
  |
3 |     spaces = spaces.len();
  |              ^^^^^^^^^^^^ expected &str, found usize
  |
  = note: expected type `&str`
             found type `usize`
```

本章节的内容就是这样啦，我们探索了变量的知识和运作原理，下一章节我们将会学习更多种变量数据类型。
